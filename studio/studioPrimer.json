{"projectName":"Studio Developer's Primer","settings":{"projectType":"json","projectDescription":"","currencySettings":[{"currencyCode":"USD","baseFormatFlag":"Yes","largeThousands":"1,234","largeMillions":"1,234,567","largeBillions":"1,234,567,891","negativeOptions":"minus","currencySymbol":"0"}],"corsAllowableDomains":[],"preferences":{"editorViewPreference":"MARKUP_MODE"}},"sampleOutput":"none","activeApiKey":false,"data":[{"id":"Primary","type":"json","jsonData":{"exampleA":"this","exampleB":"simple","exampleC":[{"name":"complex","value":"only the name is used"},{"name":"irrelevant","value":"this isn't used at all"}],"exampleD":[{"number":1,"noun":"cow"},{"number":2,"noun":"wolf"},{"number":3,"noun":"sheep"}],"exampleE":0,"exampleF":"include","exampleG":[{"object":"apple","count":4},{"object":"pear","count":8},{"object":"cake","count":1}]}}],"templates":[{"id":"Main","value":"<h4>How to Use This Primer</h4><p>Depending on which mode you are using to view this text, what you see will vary. In the <em>Compose</em> view, you’ll see the ATL; in <em>Preview</em> mode, you’ll see computed values and the data that is pulled in through the ATL. Make sure to switch back and forth between these two modes to get a good understanding of how the system works. Also, in the <em>Compose</em> view, try selecting only snippets of text with ATL to see how the <em>Preview</em> mode renders only output for those selected snippets rather than for the whole script.</p><h4>Text</h4><p>Anything you type in a script will be included in your text. Click <em>Preview</em> on the left to see the result of running your script.</p><p>You can highlight part of the script to see only the result of calling that fragment.</p><p>You can use the <strong>formatting</strong> <em>buttons</em> <u>above</u> to format your text. Behind the scenes this formats your text as HTML.<br><br></p><h4>ATL</h4><p>Anything wrapped in double square brackets is ATL.<br>E.g. 2 + 2 = [[2 + 2]]</p><p>When you run the system (or preview it), ATL gets computed and the result appears in the output.</p><p>From now on, all ATL will be in <strong>bold&nbsp;</strong>to make it easier to spot.</p><h4><br>Data</h4><p>Your data is stored in an object called WholeJSON. You can pull data from it like <strong>[[WholeJSON.exampleA]]</strong>.</p><p>Data references can be <strong>[[WholeJSON.exampleB]]</strong> or <strong>[[WholeJSON.exampleC[0].name]]</strong>. Take a look at the Data view to see where these are coming from.</p><h4><br>Functions</h4><p>Studio provides a number of functions designed to make language generation easier.</p><p>The <strong>[[numToWords(1, \"ordinal\")]]</strong> example is numToWords, which takes a number and converts it to the spelled-out form. The form can be cardinal (<strong>[[numToWords(2, \"cardinal\")]]</strong>) or ordinal (<strong>[[numToWords(3, \"ordinal\")]])</strong>. The default is cardinal (<strong>[[numToWords(4)]])</strong>.</p><p>The second example is countable. The countable function builds countable phrases like <strong>[[countable(1,'','cat')]]</strong> or <strong>[[countable(2,'','dog')]]</strong>. This method will automatically pluralize when it needs to, and will attempt to choose the correct plural form. For example: <strong>[[countable(3,'','fox')]]</strong>, <strong>[[countable(4,'','child')]]</strong>, or <strong>[[countable(5,'','appendix')]]</strong>. The second argument lets you include modifiers like so: <strong>[[countable(6, 'great', 'example')]]</strong>.</p><p>There are plenty of useful functions like <strong>[[titleCase('capitalising words')]]</strong>, calculating percentages(<strong>[[percentage(15,25,2)]]</strong>%), <strong>[[split('splitting stringsXformatting numbersXaccessing data','X')]]</strong>.</p><p>Functions are most useful when they use data references:<br><strong>[[countable(WholeJSON.exampleD[0].number, '', WholeJSON.exampleD[0].noun)]]</strong><br><strong>[[countable(WholeJSON.exampleD[1].number, '', WholeJSON.exampleD[1].noun)]]</strong><br><strong>[[countable(WholeJSON.exampleD[2].number, '', WholeJSON.exampleD[2].noun)]]</strong></p><p>You can also chain function calls together:<br><strong>[[abs(round(percentageChange(20,13),2))]]</strong>%<br><br>To add variation to a text, you can <strong>[[chooseAtRandom('use','utilise','try','make use of')]]</strong> the chooseAtRandom function. To see how this works, try previewing this snippet of the narrative multiple times.</p><h4><br>Conditions</h4><p>Conditions use the format <em>if(condition){result} elseif(condition){result} else{result}</em>. E.g.</p><p><strong>[[if(WholeJSON.exampleE == 0)<br>{This will be said if exampleE hasn't been changed.}<br>elseif(WholeJSON.exampleE &gt; 0)<br>{ExampleE has been set to a positive number}<br>else<br>{ExampleE has been set to a negative number}]]</strong></p><p>You can also use the ternary operator for shorthand ifs <strong>[[WholeJSON.exampleF == 'include' ? 'like this one' : '']]</strong>.</p><h4><br>Lambda Functions</h4><p>For more complex scripts, you can use lambda functions like map, filter, sort, reduce and forAll. These examples will all operate on the same data:</p><p><strong>[[WholeJSON.exampleG]]</strong></p><p>Map loops over a collection applying a function to each item, and returns a list of the results. This means the result will always be the same length.<br><strong>[[map(WholeJSON.exampleG, item -&gt; countable(item.count, '', item.object))]]</strong><br><br>Filter loops over a collection and uses a function to choose which items should be returned. This means the result is a list equal to or smaller than the original.<strong><br>[[filter(WholeJSON.exampleG, item -&gt; item.count &lt; 5)]]</strong><br><br>Sort loops over a collection and returns a copy ordered according to a function. The function compares two items at a time and returns a number. A negative value means A comes before B, zero means they are equal, and positive means A should be after B.<strong><br>[[sort(WholeJSON.exampleG, (A,B) -&gt; A.count - B.count)]]</strong><br>The original list is not altered.</p><p>Reduce loops over a collection and reduces it to a single value. It takes the collection, a base value, and a function that changes the current value based on the item. The result is a single item.<br><strong>[[reduce(WholeJSON.exampleG, 0, (base, item) -&gt; base + item.count)]]</strong></p><p>ForAll loops over a collection and applies a function to each item. However, it doesn't return a list, it just prints the result of each.<br><strong>[[forAll(WholeJSON.exampleG, item -&gt; countable(item.count, '', item.object))]]</strong></p><h4><br>Sub-scripts</h4><p>You can split a script up into multiple subscripts. At the top right of the screen, there's an <em>Add Script</em><strong>&nbsp;</strong>button.</p><p>You call out to a sub-script by writing its name in ATL. <strong>[[FirstSubscript]]</strong></p><p>If you open that sub-script, you can click <em>Preview</em> and see the result of running that script on its own.</p><p>You can also define scripts that take arguments. The start of the script must be:<br>#_define ScriptName(arg1, arg2)<br>but <em>without</em> the underscore (removing it makes ATL think there is a definition here).</p><p>You can then call the script in ATL. <strong>[[ParameterizedSubscript(1)]] [[ParameterizedSubscript(2)]]</strong></p><p><strong>Note:</strong> You can't call <em>Preview</em> inside a parameterized sub-script.</p><p>The most common use for forAll is to call subscripts. In fact, parameterized subscripts work as functions, so you can put them directly into the map function and use them with forAll:<br><strong>[[forAll(WholeJSON.exampleG, ObjectSubscript)]]</strong></p><h4><br>Global Variables</h4><p>Use the <em>Variables</em> view to store values that you will use throughout your report. These effectively work like global final variables. They are computed once from the data when a report is generated.</p><p>To use a variable in your text, just include it in ATL. In fact, WholeJSON is a variable that exists in all JSON projects.</p><p>This sentence is using <strong>[[VariableDescription]]</strong>.</p><p>Variables can be simple values, or they can be complex ATL. In the examples above we have <strong>[[FoodCount]]</strong> items of food. This can make it easier to read scripts, by abstracting away the logic of where values come from away.</p><h4><br>Local Variables</h4><p>ATL snippets can span multiple lines, defining intermediate variables. This is useful for breaking up calculations and reusing variables. You can optionally end each statement with a semicolon, or the system will assume each new line is a new statement.</p><p><strong>[[sortedFood = sort(WholeJSON.exampleG, (A,B) -&gt; B.count - A.count);<br>topFood = sortedFood[0];<br>topFoodName = inflectNoun(topFood.object, topFood.count);<br>otherFood = map(filter(sortedFood, x -&gt; x != topFood), y-&gt; inflectNoun(y.object, y.count));<br>FoodSupplySubscript(topFoodName, otherFood)]]</strong></p><p>It is always the last statement that appears in the output.</p><p><br></p><h1>Miscellaneous tips</h1><ul><li>You can use Shift-Enter to insert a break rather than a new paragraph; this makes things less spaced out.</li><li>The system automatically turns 'a' to 'an' where appropriate. So you have a house, a office, and a university.<s>​</s></li></ul><p><br></p>","postProcessors":[{"postProcessorId":"PP01","enabled":true}]},{"id":"FirstSubscript","value":"<p>This text was produced by the script called 'FirstSubscript'. It works just like the main script, so you can add functions, conditions, or call out to other subscripts.&nbsp;</p>"},{"id":"ParameterizedSubscript","value":"<p>#define ParameterizedSubscript(number) This is the parameterised subscript being called for the [[numToWords(number, 'ordinal')]] time.</p>"},{"id":"ObjectSubscript","value":"<p>#define ObjectSubscript(object)</p><p>We have [[countable(object.count, '', object.object)]] left in the house. [[object.count &lt; 2?'We should buy more.':'']]</p>"},{"id":"FoodSupplySubscript","value":"<p>#define FoodSupplySubscript(topFoodName, otherFood)&nbsp;</p><p>We have more [[topFoodName]] than anything else. We also have [[otherFood]].</p>"}],"lexRuleFiles":[],"mappings":[{"mappedName":"FoodCount","dataSource":"[[sum(map(WholeJSON.exampleG, i -&gt; i.count))]]","type":{"dataType":"NUMERIC"}},{"mappedName":"VariableDescription","dataSource":"a variable called VariableDescription","type":{"dataType":"STRING"}},{"mappedName":"WholeJSON","dataSource":"","type":{"dataType":"JSON"}}],"version":58,"collaborators":[],"activeUser":{"userId":"d9e5a549-08db-4ceb-adae-7fda019512f3","username":"william.bradshaw@arria.com","firstName":"William","lastName":"Bradshaw"},"postProcessors":[{"type":"Grammar","id":"PP01","correctAandAn":true,"correctCapitalisation":true}]}