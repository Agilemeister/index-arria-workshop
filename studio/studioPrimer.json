{"projectName":"Studio Developer's Primer","settings":{"projectType":"json","projectDescription":"","currencySettings":[{"currencyCode":"USD","baseFormatFlag":"Yes","largeThousands":"1,234","largeMillions":"1,234,567","largeBillions":"1,234,567,891","negativeOptions":"minus","currencySymbol":"0"}],"corsAllowableDomains":[],"preferences":{"editorViewPreference":"MARKUP_MODE"}},"sampleOutput":"none","activeApiKey":false,"data":[{"id":"Primary","type":"json","jsonData":{"exampleA":"this","exampleB":"simple","exampleC":[{"name":"complex","value":"only the name is used"},{"name":"irrelevant","value":"this isn't used at all"}],"exampleD":[{"number":1,"noun":"cow"},{"number":2,"noun":"wolf"},{"number":3,"noun":"sheep"}],"exampleE":0,"exampleF":"include","exampleG":[{"object":"apple","count":4},{"object":"pear","count":8},{"object":"cake","count":1}]}}],"templates":[{"id":"Main","value":"<h4>Text</h4><p>Anything you type in a script will be included in your text. Press the preview button on the left to see the result of running your script.</p><p>You can highlight part of the script to just see the result of calling that fragment.</p><p>You can use the <strong>formatting</strong> <em>buttons</em> <u>above</u> to format your text. Behind the scenes this formats it as HTML.<br><br></p><h4>ATL</h4><p>Anything wrapped in double square brackets is an ATL script.<br>E.g. 2 + 2 = [[2 + 2]]</p><p>When you run the system, ATL scripts are computed and the result appears in the output.</p><p>From now on all ATL scripts will be in <strong>bold&nbsp;</strong>to make them easier to spot.</p><h4><br>Data</h4><p>Your data is stored in an object called WholeJSON. You can pull data from it like <strong>[[WholeJSON.exampleA]]</strong>.</p><p>Data references can be <strong>[[WholeJSON.exampleB]]</strong> or <strong>[[WholeJSON.exampleC[0].name]]</strong>. Take a look at the data tab to see where these are coming from.</p><h4><br>Functions</h4><p>Studio provides a number of functions designed to make language generation easier.</p><p>The <strong>[[numToWords(1, \"ordinal\")]]</strong> example is numToWords, which takes a number and converts it to the spelled out form. Form can be cardinal: <strong>[[numToWords(2, \"cardinal\")]]</strong> or ordinal: <strong>[[numToWords(3, \"ordinal\")]]</strong>. The default is cardinal: <strong>[[numToWords(4)]]</strong>.</p><p>The second is countable builds countable phrases like <strong>[[countable(1,'','cat')]]</strong> or <strong>[[countable(2,'','dog')]]</strong>. This method will automatically pluralise when it needs to, and will attempt to choose the correct plural form. For example: <strong>[[countable(3,'','fox')]]</strong>, <strong>[[countable(4,'','child')]]</strong>, or <strong>[[countable(5,'','appendix')]]</strong>. The second argument lets you include modifiers like so: <strong>[[countable(6, 'great', 'example')]]</strong>.</p><p>There are plenty of useful functions like <strong>[[titleCase('capitalising words')]]</strong>, calculating percentages(<strong>[[percentage(15,25,2)]]</strong>%), <strong>[[split('splitting stringsXformatting numbersXaccessing data','X')]]</strong>.</p><p>Functions are most useful when they use data references:<br><strong>[[countable(WholeJSON.exampleD[0].number, '', WholeJSON.exampleD[0].noun)]]</strong><br><strong>[[countable(WholeJSON.exampleD[1].number, '', WholeJSON.exampleD[1].noun)]]</strong><br><strong>[[countable(WholeJSON.exampleD[2].number, '', WholeJSON.exampleD[2].noun)]]</strong></p><p>You can also chain function calls together:<br><strong>[[abs(round(percentageChange(20,13),2))]]</strong>%<br><br>To add variation to a text, you can <strong>[[chooseAtRandom('use','utilise','try','make use of')]]</strong> the chooseAtRandom function. Try running the report multiple times.</p><h4><br>Conditions</h4><p>Conditions use the format <em>if(condition){result} elseif(condition){result} else{result}</em>. E.g.</p><p><strong>[[if(WholeJSON.exampleE == 0)<br>{This will be said if exampleE hasn't been changed.}<br>elseif(WholeJSON.exampleE &gt; 0)<br>{ExampleE has been set to a positive number}<br>else<br>{ExampleE has been set to a negative number}]]</strong></p><p>You can also use the ternary operator for shorthand ifs <strong>[[WholeJSON.exampleF == 'include' ? 'like this one' : '']]</strong>.</p><h4><br>Lambda Functions</h4><p>For more complex scripts, you can use lambda functions like map, filter, sort, reduce and forAll. These examples will all operate on the same data:</p><p><strong>[[WholeJSON.exampleG]]</strong></p><p>Map loops over a collection applying a function to each item, and returns a list of the results. This means the result will always be the same length.<br><strong>[[map(WholeJSON.exampleG, item -&gt; countable(item.count, '', item.object))]]</strong><br><br>Filter loops over a collection and uses a function to choose which items should be returned. This means the result is a list equal to or smaller than the original.<strong><br>[[filter(WholeJSON.exampleG, item -&gt; item.count &lt; 5)]]</strong><br><br>Sort loops over a collection and returns a copy ordered according to a function. The function compares two items at a time and returns a number. A negative value means A comes before B, zero means they are equal, and positive means A should be after B.<strong><br>[[sort(WholeJSON.exampleG, (A,B) -&gt; A.count - B.count)]]</strong><br>The original list is not altered.</p><p>Reduce loops over a collection and reduces it to a single value. It takes the collection, a base value, and a function that changes the current value based on the item. The result is a single item.<br><strong>[[reduce(WholeJSON.exampleG, 0, (base, item) -&gt; base + item.count)]]</strong></p><p>ForAll loops over a collection and applies a function to each item. However, it doesn't return a list, it just prints the result of each.<br><strong>[[forAll(WholeJSON.exampleG, item -&gt; countable(item.count, '', item.object))]]</strong></p><h4><br>Sub-scripts</h4><p>You can split a script up into multiple subscripts. If you scroll to the top, there's an add scripts button.</p><p>You call out to the script by writing its name in ATL. <strong>[[FirstSubscript]]</strong></p><p>If you open that script, you can click preview and it will return the result of running that script on its own.</p><p>You can also define scripts that take arguments. The start of the script needs to be:<br>#_define ScriptName(arg1, arg2)<br>Without the underscore (removing it makes ATL think there is a definition here).</p><p>You can then call the script in ATL. <strong>[[ParameterizedSubscript(1)]] [[ParameterizedSubscript(2)]]</strong></p><p>Please note that you can't call preview inside a parameterized subscript.</p><p>The most common use for forAll is to call subscripts. In fact, parameterized subscripts work as functions, so you can put them directly into maps and forAll:<br><strong>[[forAll(WholeJSON.exampleG, ObjectSubscript)]]</strong></p><h4><br>Global Variables</h4><p>You can use the variables tab to store values that you will use throughout your report. These effectively work like global final variables. They are computed once from the data when a report is generated.</p><p>To use a variable in your text, just include it in ATL. In fact, WholeJSON is a variable that exists in all JSON projects.</p><p>This sentence is using <strong>[[VariableDescription]]</strong>.</p><p>Variables can be simple values, or they can be complex ATL. In the examples above we have <strong>[[FoodCount]]</strong> items of food. This can make it easier to read scripts, by abstracting the logic of where values come from away.</p><h4><br>Local Variables</h4><p>ATL scripts can span multiple lines, defining intermediate variables. This is useful for breaking up calculations and reusing variables. You can optionally end each statement with a semicolon, or the system will assuming each new line is a new statement.</p><p><strong>[[sortedFood = sort(WholeJSON.exampleG, (A,B) -&gt; B.count - A.count);<br>topFood = sortedFood[0];<br>topFoodName = inflectNoun(topFood.object, topFood.count);<br>otherFood = map(filter(sortedFood, x -&gt; x != topFood), y-&gt; inflectNoun(y.object, y.count));<br>FoodSupplySubscript(topFoodName, otherFood)]]</strong></p><p>It is always the last statement which appears in the output.</p><p><br></p><h1>Miscellanious tips</h1><ul><li>You can use shift-enter to insert a break rather than a new paragraph, which means things are less spaced out.</li><li>The system automatically turns 'a' to 'an' where appropriate. So you have a house, a office, and a university.</li></ul><p><br></p>","postProcessors":[{"postProcessorId":"PP01","enabled":true}]},{"id":"FirstSubscript","value":"<p>This text was produced by the script called 'FirstSubscript'. It works just like the main script, so you can add functions, conditions, or call out to other subscripts.&nbsp;</p>"},{"id":"ParameterizedSubscript","value":"<p>#define ParameterizedSubscript(number) This is the parameterised subscript being called for the [[numToWords(number, 'ordinal')]] time.</p>"},{"id":"ObjectSubscript","value":"<p>#define ObjectSubscript(object)</p><p>We have [[countable(object.count, '', object.object)]] left in the house. [[object.count &lt; 2?'We should buy more.':'']]</p>"},{"id":"FoodSupplySubscript","value":"<p>#define FoodSupplySubscript(topFoodName, otherFood)&nbsp;</p><p>We have more [[topFoodName]] than anything else. We also have [[otherFood]].</p>"}],"lexRuleFiles":[],"mappings":[{"mappedName":"FoodCount","dataSource":"[[sum(map(WholeJSON.exampleG, i -&gt; i.count))]]","type":{"dataType":"NUMERIC"}},{"mappedName":"VariableDescription","dataSource":"a variable called VariableDescription","type":{"dataType":"STRING"}},{"mappedName":"WholeJSON","dataSource":"","type":{"dataType":"JSON"}}],"version":503,"collaborators":[],"activeUser":{"userId":"d9e5a549-08db-4ceb-adae-7fda019512f3","username":"william.bradshaw@arria.com","firstName":"William","lastName":"Bradshaw"},"postProcessors":[{"type":"Grammar","id":"PP01","correctAandAn":true,"correctCapitalisation":true}]}